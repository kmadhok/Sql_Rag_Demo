"""
RAG Service for SQL RAG application
"""
import logging
from typing import Dict, Any, Optional
import requests
from datetime import datetime
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))
from config import settings

logger = logging.getLogger(__name__)

class RAGService:
    def __init__(self):
        self.project_id = settings.BIGQUERY_PROJECT_ID
        self.location = settings.MODEL_LOCATION
        self.gemini_api_key = settings.GEMINI_API_KEY
        self.clients = {}
        
        # Check if we have real API keys
        self.use_real_ai = self._validate_api_key()
        
        # Debug logging
        logger.info(f"üîë Gemini API Key detected: {'YES' if self.gemini_api_key else 'NO'}")
        logger.info(f"ü§ñ Using Real AI: {'YES' if self.use_real_ai else 'NO'}")
        
        if self.use_real_ai:
            logger.info("‚úÖ Using real Gemini AI for responses")
        else:
            logger.error("‚ùå Gemini AI service unavailable - missing or invalid API key")
    
    def _validate_api_key(self) -> bool:
        """Validate Gemini API key format and presence"""
        if not self.gemini_api_key:
            return False
        
        # Check for placeholder/demo keys
        placeholder_keys = [
            "demo-key", 
            "your_actual_gemini_api_key_here", 
            "your-gemini-api-key",
            "replace-with-your-key",
            "sk-demo"
        ]
        
        if self.gemini_api_key in placeholder_keys:
            return False
        
        # Basic format check (real Gemini keys usually start with specific patterns)
        # Note: Gemini API keys don't have a fixed prefix like OpenAI's "sk-"
        if len(self.gemini_api_key) < 20:  # Real keys are lengthier
            return False
            
        return True
    
    def process_query(
        self, 
        question: str, 
        agent_type: str = "normal",
        context: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Process a user query with RAG
        """
        try:
            if self.use_real_ai:
                return self._process_with_gemini(question, agent_type)
            else:
                return self._create_config_error_response(question, agent_type)
                
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return self._create_error_response(
                error_code="PROCESSING_ERROR",
                message=f"Error processing query: {str(e)}",
                question=question,
                agent_type=agent_type,
                original_error=str(e)
            )
    
    def _process_with_gemini(self, question: str, agent_type: str) -> Dict[str, Any]:
        """
        Process query using Google Gemini AI
        """
        # Build prompt based on agent type
        prompt = self._build_prompt(question, agent_type)
        
        try:
            # Call Gemini API
            response = requests.post(
                "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
                headers={
                    "Content-Type": "application/json",
                    "x-goog-api-key": self.gemini_api_key
                },
                json={
                    "contents": [{
                        "parts": [{
                            "text": prompt
                        }]
                    }],
                    "generationConfig": {
                        "temperature": 0.3,
                        "maxOutputTokens": 1000
                    }
                },
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                message_text = result["candidates"][0]["content"]["parts"][0]["text"]
                
                # Extract SQL if present
                sql_query = self._extract_sql_from_response(message_text, question)
                
                return {
                    "message": message_text,
                    "sql_query": sql_query or "SELECT * FROM users LIMIT 10;",
                    "sql_executed": False,
                    "sources": [{"name": "Gemini AI", "content": "Generated by Google Gemini 2.0 Flash"}],
                    "token_usage": {
                        "prompt": len(prompt.encode()),
                        "completion": len(message_text.encode()),
                        "total": len(prompt.encode()) + len(message_text.encode())
                    },
                    "session_id": "gemini-ai-session",
                    "timestamp": datetime.now().isoformat(),
                    "processing_time": 0.5,
                    "agent_used": agent_type
                }
            else:
                logger.error(f"Gemini API error: {response.status_code} - {response.text}")
                return self._create_api_error_response(
                    status_code=response.status_code,
                    error_text=response.text,
                    question=question,
                    agent_type=agent_type
                )
                
        except Exception as e:
            logger.error(f"Error calling Gemini API: {e}")
            return self._create_error_response(
                error_code="API_CALL_ERROR",
                message=f"Unable to connect to Gemini AI service: {str(e)}",
                question=question,
                agent_type=agent_type,
                original_error=str(e)
            )
    
    def _create_config_error_response(self, question: str, agent_type: str) -> Dict[str, Any]:
        """
        Create clear configuration error response when API key is missing
        """
        return {
            "error": "AI_SERVICE_UNAVAILABLE",
            "error_code": "MISSING_GEMINI_API_KEY",
            "message": "Gemini AI service is unavailable due to missing configuration.",
            "details": {
                "missing_config": "GEMINI_API_KEY environment variable is not set or contains a placeholder value",
                "solution": "Add your Gemini API key to the .env file",
                "example": "GEMINI_API_KEY=AIzaSy...your_actual_api_key",
                "help_url": "https://makersuite.google.com/app/apikey"
            },
            "sql_query": None,
            "sources": [],
            "token_usage": {"prompt": 0, "completion": 0, "total": 0},
            "session_id": "error-session",
            "timestamp": datetime.now().isoformat(),
            "processing_time": 0.001,
            "agent_used": agent_type
        }
    
    def _create_api_error_response(self, status_code: int, error_text: str, question: str, agent_type: str) -> Dict[str, Any]:
        """
        Create API error response when Gemini API call fails
        """
        error_details = {
            400: "Bad Request - Invalid request format",
            401: "Unauthorized - Invalid API key", 
            403: "Forbidden - API key doesn't have required permissions",
            429: "Too Many Requests - Rate limit exceeded",
            500: "Internal Server Error - Gemini AI service issue",
            503: "Service Unavailable - Gemini AI temporarily down"
        }
        
        return {
            "error": "API_ERROR",
            "error_code": f"GEMINI_API_{status_code}",
            "message": f"Gemini AI API returned error: {status_code}",
            "details": {
                "api_status_code": status_code,
                "api_error_description": error_details.get(status_code, "Unknown error"),
                "api_response": error_text[:500] if error_text else "No error details"
            },
            "sql_query": None,
            "sources": [],
            "token_usage": {"prompt": 0, "completion": 0, "total": 0},
            "session_id": "api-error-session",
            "timestamp": datetime.now().isoformat(),
            "processing_time": 0.5,
            "agent_used": agent_type
        }
    
    def _create_error_response(self, error_code: str, message: str, question: str, agent_type: str, original_error: str = None) -> Dict[str, Any]:
        """
        Create a generic error response
        """
        return {
            "error": "SERVICE_ERROR",
            "error_code": error_code,
            "message": message,
            "details": {
                "question": question[:100] + ("..." if len(question) > 100 else ""),
                "agent_type": agent_type,
                "original_error": original_error[:200] if original_error else None
            },
            "sql_query": None,
            "sources": [],
            "token_usage": {"prompt": 0, "completion": 0, "total": 0},
            "session_id": "error-session",
            "timestamp": datetime.now().isoformat(),
            "processing_time": 0.001,
            "agent_used": agent_type
        }
    
    def _build_prompt(self, question: str, agent_type: str) -> str:
        """
        Build appropriate prompt based on agent type
        """
        base_context = """You are a helpful SQL assistant. The database has tables: users(id, name, email, created_at), orders(id, user_id, product_name, amount, order_date), and products(id, name, category, price, in_stock)."""
        
        agent_prompts = {
            "normal": base_context + "\n\nAnswer the user's question and provide the SQL query to answer it.",
            "create": base_context + "\n\nHelp the user write a SQL query for their request. Explain the query clearly.",
            "explain": base_context + "\n\nExplain what the given SQL query does in detail, including how it works and what results it returns.",
            "schema": base_context + "\n\nDescribe the database schema relevant to the user's question.",
            "longanswer": base_context + "\n\nProvide a detailed, comprehensive answer to the user's question with examples."
        }
        
        return f"{agent_prompts.get(agent_type, agent_prompts['normal'])}\n\nUser Question: {question}"
    
    def _extract_sql_from_response(self, response: str, question: str) -> Optional[str]:
        """Extract SQL from AI response if present"""
        import re
        
        # Look for SQL code blocks
        sql_pattern = r'```sql\s*(.*?)\s*```'
        matches = re.findall(sql_pattern, response, re.DOTALL | re.IGNORECASE)
        
        if matches:
            return matches[0].strip()
        
        return None

# Global instance
rag_service = RAGService()


# ======================================
# TEST SUITE - Run directly with: python rag_service.py
# ======================================
if __name__ == "__main__":
    import json
    import time
    from datetime import datetime
    
    def print_header(title):
        """Print formatted test header"""
        print("\n" + "=" * 60)
        print(f"üß™ {title}")
        print("=" * 60)
    
    def print_test_result(test_name, passed, details=None):
        """Print test result with details"""
        status = "‚úÖ PASSED" if passed else "‚ùå FAILED"
        print(f"   {test_name}: {status}")
        if details:
            print(f"      {details}")
    
    def test_service_initialization():
        """Test RAGService initialization"""
        print_header("Testing RAG Service Initialization")
        
        # Test initialization
        service = RAGService()
        
        # Check basic attributes
        print_test_result(
            "Service object created", 
            service is not None,
            f"Service type: {type(service).__name__}"
        )
        
        print_test_result(
            "API key loaded",
            service.gemini_api_key is not None,
            f"Key length: {len(service.gemini_api_key) if service.gemini_api_key else 0} chars"
        )
        
        print_test_result(
            "API key validation",
            isinstance(service.use_real_ai, bool),
            f"Real AI enabled: {service.use_real_ai}"
        )
        
        return service
    
    def test_api_key_validation():
        """Test API key validation logic"""
        print_header("Testing API Key Validation")
        
        # Create a test instance to check validation
        service = RAGService()
        
        test_keys = [
            (None, False, "None key"),
            ("", False, "Empty string"),
            ("demo-key", False, "Demo placeholder"),
            ("your_actual_gemini_api_key_here", False, "Template placeholder"),
            ("short", False, "Too short key"),
            ("AIzaSyCbVN12345678901234567890123456789", True, "Valid length key")
        ]
        
        for test_key, expected, description in test_keys:
            # Temporarily set the key for testing
            original_key = service.gemini_api_key
            service.gemini_api_key = test_key
            
            # Test validation
            actual = service._validate_api_key()
            
            print_test_result(
                f"Key validation: {description}",
                actual == expected,
                f"Expected: {expected}, Got: {actual}"
            )
            
            # Restore original key
            service.gemini_api_key = original_key
    
    def test_error_responses():
        """Test error response generation"""
        print_header("Testing Error Response Generation")
        
        service = RAGService()
        test_question = "Show me expensive products"
        test_agent = "normal"
        
        # Test config error response
        config_error = service._create_config_error_response(test_question, test_agent)
        
        print_test_result(
            "Config error response format",
            all(key in config_error for key in ["error", "error_code", "message", "details"]),
            "Contains required fields: error, error_code, message, details"
        )
        
        print_test_result(
            "Config error code",
            config_error["error_code"] == "MISSING_GEMINI_API_KEY",
            f"Error code: {config_error['error_code']}"
        )
        
        print_test_result(
            "Config error includes solution",
            "solution" in config_error["details"],
            "Solution provided in details"
        )
        
        # Test API error response
        api_error = service._create_api_error_response(401, "Unauthorized", test_question, test_agent)
        
        print_test_result(
            "API error response format",
            all(key in api_error for key in ["error", "error_code", "details"]),
            "Contains required fields"
        )
        
        print_test_result(
            "API error code format",
            api_error["error_code"] == "GEMINI_API_401",
            "Properly formatted status code in error code"
        )
        
        # Test generic error response
        generic_error = service._create_error_response(
            "TEST_ERROR", "Test message", test_question, test_agent, "Original error details"
        )
        
        print_test_result(
            "Generic error response",
            generic_error["error_code"] == "TEST_ERROR",
            "Custom error code preserved"
        )
    
    def test_prompt_building():
        """Test prompt building for different agent types"""
        print_header("Testing Prompt Building")
        
        service = RAGService()
        test_question = "How many users exist?"
        
        agent_types = ["normal", "create", "explain", "schema", "longanswer", "unknown"]
        
        for agent_type in agent_types:
            prompt = service._build_prompt(test_question, agent_type)
            
            print_test_result(
                f"Prompt built for {agent_type} agent",
                test_question in prompt,
                f"Prompt length: {len(prompt)} chars"
            )
            
            # Check that prompt contains context
            print_test_result(
                f"{agent_type} prompt has context",
                "database" in prompt.lower(),
                "Contains database context"
            )
    
    def test_sql_extraction():
        """Test SQL extraction from AI responses"""
        print_header("Testing SQL Extraction")
        
        service = RAGService()
        
        test_cases = [
            (
                "Here's the query:\n```sql\nSELECT * FROM users;\n```",
                "SELECT * FROM users;",
                "Basic SQL in code block"
            ),
            (
                "```SQL\nSELECT COUNT(*) FROM orders;\n```",
                "SELECT COUNT(*) FROM orders;",
                "SQL with uppercase code block"
            ),
            (
                "```sql\nSELECT u.name, COUNT(o.id)\nFROM users u\nJOIN orders o ON u.id = o.user_id\nGROUP BY u.name;\n```",
                "SELECT u.name, COUNT(o.id)\nFROM users u\nJOIN orders o ON u.id = o.user_id\nGROUP BY u.name;",
                "Multi-line SQL query"
            ),
            (
                "No SQL here, just text response",
                None,
                "No SQL present"
            )
        ]
        
        for response_text, expected_sql, description in test_cases:
            extracted_sql = service._extract_sql_from_response(response_text, "test question")
            
            print_test_result(
                f"SQL extraction: {description}",
                extracted_sql == expected_sql,
                f"Expected: {expected_sql}, Got: {extracted_sql}"
            )
    
    def test_processing_with_mock_environment():
        """Test query processing in different scenarios"""
        print_header("Testing Query Processing")
        
        # Save original key
        import os
        original_key = os.environ.get('GEMINI_API_KEY')
        
        try:
            # Test 1: Missing API key
            print("\nüìã Scenario 1: Missing/invalid API key")
            os.environ['GEMINI_API_KEY'] = 'demo-key'
            service_no_key = RAGService()
            
            result = service_no_key.process_query(
                question="Show me expensive products",
                agent_type="normal"
            )
            
            print_test_result(
                "Returns error for invalid key",
                'error' in result,
                f"Error: {result.get('error_code', 'Unknown')}"
            )
            
            print_test_result(
                "No fake SQL generated",
                result.get('sql_query') is None,
                "SQL query is None as expected"
            )
            
            print_test_result(
                "Processing time is minimal",
                result['processing_time'] < 0.01,
                f"Time: {result['processing_time']}s (should be < 0.01s)"
            )
            
        finally:
            # Restore original key
            if original_key:
                os.environ['GEMINI_API_KEY'] = original_key
            else:
                os.environ.pop('GEMINI_API_KEY', None)
    
    def test_real_api_if_available():
        """Test real API call if API key is available"""
        print_header("Testing Real API Integration")
        
        service = RAGService()
        
        if not service.use_real_ai:
            print("‚ÑπÔ∏è  Skipping real API test - no valid API key available")
            print("   To test real API: Set GEMINI_API_KEY in environment")
            return
        
        print("‚úÖ Valid API key detected - testing real Gemini integration")
        
        test_questions = [
            "Show me the most expensive products",
            "How many users are there?"
        ]
        
        for i, question in enumerate(test_questions, 1):
            print(f"\nüìã Test {i}: {question}")
            
            start_time = time.time()
            result = service.process_query(
                question=question,
                agent_type="normal"
            )
            end_time = time.time()
            
            print_test_result(
                f"API call successful",
                'error' not in result,
                f"Response type: {'Success' if 'error' not in result else 'Error'}"
            )
            
            if 'error' not in result:
                print_test_result(
                    "Has message content",
                    len(result.get('message', '')) > 0,
                    f"Message length: {len(result.get('message', ''))} chars"
                )
                
                print_test_result(
                    "Has SQL query",
                    result.get('sql_query') is not None,
                    f"SQL: {result.get('sql_query', 'None')[:50]}..."
                )
                
                print_test_result(
                    "Token usage tracked",
                    result['token_usage']['total'] > 0,
                    f"Total tokens: {result['token_usage']['total']}"
                )
            
            print_test_result(
                "Response time reasonable",
                end_time - start_time < 10,  # Should complete within 10 seconds
                f"Duration: {end_time - start_time:.2f}s"
            )
    
    def run_all_tests():
        """Run all test suites"""
        print("\nüöÄ RAG Service Test Suite Starting")
        print(f"üïê Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        test_results = []
        
        try:
            # Run test suites
            service = test_service_initialization()
            test_api_key_validation()
            test_error_responses()
            test_prompt_building()
            test_sql_extraction()
            test_processing_with_mock_environment()
            test_real_api_if_available()
            
            print_header("All Tests Completed")
            print("\n‚úÖ RAG Service test suite completed successfully!")
            print("\nüìù Summary:")
            print("   - Service initialization: ‚úÖ")
            print("   - API key validation: ‚úÖ")
            print("   - Error response generation: ‚úÖ")
            print("   - Prompt building: ‚úÖ")
            print("   - SQL extraction: ‚úÖ")
            print("   - Query processing: ‚úÖ")
            if service.use_real_ai:
                print("   - Real API integration: ‚úÖ")
            else:
                print("   - Real API integration: ‚è≠Ô∏è (skipped - no API key)")
            
        except Exception as e:
            print(f"\n‚ùå Test suite failed with error: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"\nüïê Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Run all tests
    run_all_tests()
    
    print("\nüí° To run individual test suites, modify the 'run_all_tests()' function")
    print("üí° To test with different API keys, set GEMINI_API_KEY environment variable")