query,description
"SELECT t1.category_id, t1.description, COUNT(*) as count_email FROM categories t1 LEFT JOIN customer_contacts t2 ON t1.category_id = t2.customer_id GROUP BY t1.category_id, t1.description ORDER BY count_email ASC;","This SQL query retrieves each category's ID and description from the 'categories' table along with a count of associated customer contacts (indicating potential email communications) in the 'customer_contacts' table. It groups results by category, orders them by ascending contact counts, and may help identify categories with fewer or no email interactions."
"SELECT t1.preferred_contact_method, t1.email, t1.contact_id, COUNT(t2.stock_level) as count_stock_level FROM customer_contacts t1 INNER JOIN inventory t2 ON t1.customer_id = t2.product_id GROUP BY t1.preferred_contact_method, t1.email, t1.contact_id ORDER BY t1.contact_id ASC;","This query retrieves each customer's preferred contact method, email, and unique identifier (contact ID), along with the total stock levels of products associated with them from a join between 'customer_contacts' and 'inventory' tables, ordered by contact ID. It groups results based on contact preferences and emails to provide insights into inventory status linked to customer communication methods."
"SELECT t1.last_name, t1.department_id, t1.hire_date, COUNT(t2.zip_code) as count_zip_code FROM employees t1 RIGHT JOIN locations t2 ON t1.employee_id = t2.location_id GROUP BY t1.last_name, t1.department_id, t1.hire_date ORDER BY t1.last_name DESC;","This SQL query retrieves the last name, department ID, and hire date of employees from a joined table of employees and locations, along with the count of unique zip codes associated with each employee's location. The results are grouped by last name, department, and hire date, ordered in descending order by last name."
"SELECT t1.shipment_id, t1.tracking_number, t1.shipment_date, SUM(t2.status) as sum_status FROM shipments t1 RIGHT JOIN return_orders t2 ON t1.order_id = t2.order_id GROUP BY t1.shipment_id, t1.tracking_number, t1.shipment_date ORDER BY t1.shipment_date ASC;","This query retrieves shipment details (ID, tracking number, and date) along with the total status count from return orders for each shipment, grouped by shipment ID, tracking number, and date, in ascending order of shipment date. The key tables involved are 'shipments' and 'return_orders'."
"SELECT t1.contact_id, t1.preferred_contact_method, MAX(t2.payment_date) as max_payment_date FROM customer_contacts t1 RIGHT JOIN payments t2 ON t1.customer_id = t2.payment_id GROUP BY t1.contact_id, t1.preferred_contact_method ORDER BY max_payment_date DESC;","This SQL query retrieves the contact ID and preferred communication method of customers from the 'customer_contacts' table, along with the latest payment date for each customer by joining it with the 'payments' table on customer ID. The results are grouped by contact ID and preferred communication method, sorted in descending order based on the most recent payment date."
"SELECT t1.order_id, t1.status, t1.order_date, COUNT(t2.city) as count_city FROM orders t1 INNER JOIN locations t2 ON t1.customer_id = t2.location_id GROUP BY t1.order_id, t1.status, t1.order_date ORDER BY count_city ASC;","This SQL query retrieves the order ID, status, and date for each order from the 'orders' table (t1), along with a count of cities associated with each order from the 'locations' table (t2). It groups results by order ID, status, and date, then sorts them in ascending order based on the number of unique cities linked to each order."
"SELECT t1.return_id, t1.refund_amount, COUNT(*) as count_city FROM return_orders t1 INNER JOIN locations t2 ON t1.return_id = t2.location_id GROUP BY t1.return_id, t1.refund_amount ORDER BY t1.return_id DESC;","This SQL query retrieves the return ID and refund amount from the 'return_orders' table (t1) and counts the number of locations associated with each return by joining it with the 'locations' table (t2). The results are grouped by return ID and refund amount, ordered in descending order based on return ID.

Key tables: 
- return_orders (t1): Contains information about returns, including return ID and refund amount.
- locations (t2): Stores location data associated with each return.

Metrics:
- Return ID
- Refund Amount
- Count of cities per return (count_city)"
"SELECT t1.product_id, t1.stock, COUNT(t2.category_name) as count_category_name FROM products t1 LEFT JOIN categories t2 ON t1.category_id = t2.category_id GROUP BY t1.product_id, t1.stock ORDER BY count_category_name DESC;","This SQL query retrieves the product ID and stock quantity from the ""products"" table, along with a count of distinct category names associated with each product (from the ""categories"" table), then groups the results by product ID and stock quantity. The output is sorted in descending order based on the number of categories per product. This helps to identify products that belong to multiple categories or have high diversity in their categorization, which could be useful for inventory management or marketing strategies."
"SELECT t1.status, t1.order_id, t1.refund_amount, MIN(t2.city) as min_city FROM return_orders t1 INNER JOIN locations t2 ON t1.return_id = t2.location_id GROUP BY t1.status, t1.order_id, t1.refund_amount ORDER BY min_city DESC;","This SQL query retrieves the order status, order ID, and refund amount from return orders (t1) joined with locations (t2) based on matching return IDs and location IDs. It groups results by status, order ID, and refund amount, then selects the minimum city for each group and sorts them in descending order of cities. The purpose is to analyze refund amounts across different statuses and orders while considering their geographical distribution."
"SELECT t1.product_id, t1.unit_price, MIN(t2.zip_code) as min_zip_code FROM products t1 RIGHT JOIN locations t2 ON t1.category_id = t2.location_id GROUP BY t1.product_id, t1.unit_price ORDER BY t1.product_id DESC;","This SQL query retrieves the product ID and unit price from the 'products' table and finds the minimum zip code associated with each product category in the 'locations' table. It groups results by product ID and unit price, then orders them in descending order based on product ID. The purpose is to analyze products' distribution across different locations."
"SELECT t1.zip_code, t1.location_id, t1.state, MIN(t2.payment_date) as min_payment_date FROM locations t1 INNER JOIN payments t2 ON t1.location_id = t2.payment_id GROUP BY t1.zip_code, t1.location_id, t1.state ORDER BY min_payment_date DESC;","This SQL query retrieves the minimum payment date for each location (identified by zip code, location ID, and state) by joining the 'locations' table with the 'payments' table on matching location IDs. The results are grouped by location attributes and ordered in descending order based on the earliest payment date."
"SELECT t1.category_id, t1.product_id, t1.unit_price, COUNT(*) as count_tracking_number FROM products t1 LEFT JOIN shipments t2 ON t1.category_id = t2.shipment_id GROUP BY t1.category_id, t1.product_id, t1.unit_price ORDER BY count_tracking_number ASC;","This SQL query retrieves the category ID, product ID, and unit price of products from the 'products' table, along with a count of associated tracking numbers from the 'shipments' table (if any), grouped by category, product, and unit price. It orders the results in ascending order based on the number of tracking numbers linked to each product within its category."
"SELECT t1.payment_id, t1.payment_date, t1.amount, SUM(t2.order_date) as sum_order_date FROM payments t1 LEFT JOIN orders t2 ON t1.order_id = t2.order_id GROUP BY t1.payment_id, t1.payment_date, t1.amount ORDER BY sum_order_date DESC;","This SQL query retrieves payment information (payment ID, date, and amount) from the payments table and calculates the total order dates for each payment by joining with the orders table on order IDs. It groups results by payment details and sorts them in descending order based on the sum of order dates associated with each payment."
"SELECT t1.return_date, t1.return_id, t1.refund_amount, COUNT(t2.department_name) as count_department_name FROM return_orders t1 LEFT JOIN departments t2 ON t1.return_id = t2.department_id GROUP BY t1.return_date, t1.return_id, t1.refund_amount ORDER BY count_department_name ASC;","This SQL query retrieves the return date, return ID, and refund amount from the 'return_orders' table, while also counting the number of associated department names for each return in the 'departments' table. It groups the results by return date, ID, and refund amount, ordering them in ascending order based on the count of department names per return."
"SELECT t1.price, t1.product_id, COUNT(t2.unit_price) as count_unit_price FROM sales t1 RIGHT JOIN products t2 ON t1.product_id = t2.product_id GROUP BY t1.price, t1.product_id ORDER BY count_unit_price DESC;","This SQL query retrieves the price and product ID from the 'sales' table (t1), along with a count of distinct unit prices associated with each product in the 'products' table (t2). It groups the results by price and product ID, then orders them in descending order based on the count of unique unit prices.

Key tables: sales (t1), products (t2)
Metrics: Price, Product ID, Count of distinct Unit Prices"
"SELECT t1.address, t1.location_id, SUM(t2.refund_amount) as sum_refund_amount FROM locations t1 LEFT JOIN return_orders t2 ON t1.location_id = t2.order_id GROUP BY t1.address, t1.location_id ORDER BY sum_refund_amount ASC;","This SQL query retrieves the address and location ID from the 'locations' table and calculates the total refund amount for each location by joining with the 'return_orders' table on matching order IDs, then groups the results by address and location ID. The output is sorted in ascending order based on the sum of refund amounts."
"SELECT t1.city, t1.customer_id, COUNT(*) as count_product_name FROM customers t1 INNER JOIN products t2 ON t1.customer_id = t2.product_id GROUP BY t1.city, t1.customer_id ORDER BY t1.city DESC;","This SQL query retrieves the city and customer ID from the 'customers' table (t1), along with a count of unique product names associated with each customer in that city, by joining it with the 'products' table (t2) on matching customer IDs. The results are grouped by city and customer ID and ordered by city in descending order."
"SELECT t1.supplier_id, t1.supplier_name, MAX(t2.description) as max_description FROM suppliers t1 LEFT JOIN categories t2 ON t1.supplier_id = t2.category_id GROUP BY t1.supplier_id, t1.supplier_name ORDER BY max_description ASC;","This SQL query retrieves the supplier ID and name along with their maximum category description from a joined table of suppliers and categories, grouping by supplier details, and orders the results based on the maximum description in ascending order. The purpose is to identify unique suppliers and their most frequently used category descriptions."
"SELECT t1.order_id, t1.status, COUNT(t2.quantity) as count_quantity FROM orders t1 INNER JOIN sales t2 ON t1.customer_id = t2.product_id GROUP BY t1.order_id, t1.status ORDER BY count_quantity ASC;","This SQL query retrieves the order ID and status from the 'orders' table (t1), along with a count of quantities sold per order from the 'sales' table (t2). It groups results by order ID and status, then orders them in ascending order based on the total quantity sold. The purpose is to analyze sales performance for each order."
"SELECT t1.return_id, t1.refund_amount, SUM(t2.description) as sum_description FROM return_orders t1 LEFT JOIN categories t2 ON t1.return_id = t2.category_id GROUP BY t1.return_id, t1.refund_amount ORDER BY sum_description ASC;","This SQL query retrieves the return ID and refund amount from the 'return_orders' table, while also calculating the total description count for each return by joining with the 'categories' table on category IDs. The results are grouped by return ID and refund amount, then ordered in ascending order based on the sum of descriptions."
"SELECT t1.first_name, t1.employee_id, MIN(t2.state) as min_state FROM employees t1 LEFT JOIN locations t2 ON t1.employee_id = t2.location_id GROUP BY t1.first_name, t1.employee_id ORDER BY min_state ASC;","This SQL query retrieves the first name and employee ID of each employee along with their earliest recorded state from a locations table, grouping results by both first name and employee ID, and orders them in ascending order based on the minimum state value. The key tables involved are 'employees' and 'locations'."
"SELECT t1.category_id, t1.category_name, MIN(t2.stock_level) as min_stock_level FROM categories t1 RIGHT JOIN inventory t2 ON t1.category_id = t2.warehouse_id GROUP BY t1.category_id, t1.category_name ORDER BY min_stock_level ASC;","This SQL query retrieves the minimum stock level for each category by joining categories and inventory tables on their respective IDs, grouping results by category ID and name, and ordering them in ascending order based on the lowest stock levels found. The purpose is to identify categories with the least available inventory across warehouses."
"SELECT t1.category_id, t1.description, MIN(t2.tracking_number) as min_tracking_number FROM categories t1 INNER JOIN shipments t2 ON t1.category_id = t2.order_id GROUP BY t1.category_id, t1.description ORDER BY min_tracking_number DESC;","This SQL query retrieves the minimum tracking number for each category and description from the 'categories' table by joining it with the 'shipments' table on their corresponding IDs. The result is grouped by category ID and description, and ordered in descending order based on the minimum tracking number. This helps identify categories with lower shipment tracking numbers, potentially indicating faster delivery times or more efficient processes."
"SELECT t1.email, t1.phone, SUM(t2.status) as sum_status FROM customer_contacts t1 INNER JOIN return_orders t2 ON t1.contact_id = t2.order_id GROUP BY t1.email, t1.phone ORDER BY sum_status DESC;","This SQL query retrieves customers' email and phone numbers along with the total count of their associated return orders (sum_status), grouping by each customer contact. It sorts the results in descending order based on the number of return orders per customer.

Key tables: 
- customer_contacts (t1)
- return_orders (t2)

Metrics:
- email, phone, sum_status (total count of associated return orders)."
"SELECT t1.state, t1.supplier_id, t1.city, MIN(t2.product_name) as min_product_name FROM suppliers t1 LEFT JOIN products t2 ON t1.supplier_id = t2.product_id GROUP BY t1.state, t1.supplier_id, t1.city ORDER BY min_product_name ASC;","This SQL query retrieves the state, supplier ID, and city from the 'suppliers' table (t1), along with the minimum product name associated with each supplier in a given location, by joining it with the 'products' table (t2) on matching supplier IDs. The results are grouped by state, supplier ID, and city, then ordered ascendingly based on the minimum product name found for each group."
"SELECT t1.category_id, t1.description, COUNT(t2.stock_level) as count_stock_level FROM categories t1 LEFT JOIN inventory t2 ON t1.category_id = t2.product_id GROUP BY t1.category_id, t1.description ORDER BY count_stock_level DESC;","This SQL query retrieves each category's ID and description from the 'categories' table, along with a count of associated stock levels from the 'inventory' table (only including categories without matching product IDs), and orders the results by descending stock level counts. The purpose is to identify categories with high inventory quantities for potential restocking or analysis."
"SELECT t1.order_id, t1.return_id, MAX(t2.amount) as max_amount FROM return_orders t1 INNER JOIN payments t2 ON t1.order_id = t2.order_id GROUP BY t1.order_id, t1.return_id ORDER BY max_amount DESC;","This SQL query retrieves the order and return IDs along with the maximum payment amount for each combination of order and return ID from a joined table of return orders and payments, grouping by both order and return IDs, and sorts the results in descending order based on the maximum payment amount. The key tables involved are 'return_orders' (t1) and 'payments' (t2), with the metric being the maximum payment amount ('max_amount')."
"SELECT t1.product_id, t1.product_name, MAX(t2.quantity) as max_quantity FROM products t1 INNER JOIN order_details t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id, t1.product_name ORDER BY max_quantity ASC;","This SQL query retrieves each product's ID and name along with the maximum quantity sold for that product from the 'products' and 'order_details' tables, grouping by product ID and name, and orders the results in ascending order based on the maximum quantity sold. The purpose is to identify products with lower sales volumes."
"SELECT t1.zip_code, t1.address, t1.city, MIN(t2.category_name) as min_category_name FROM locations t1 RIGHT JOIN categories t2 ON t1.location_id = t2.category_id GROUP BY t1.zip_code, t1.address, t1.city ORDER BY min_category_name ASC;","This SQL query retrieves the minimum category name for each unique combination of zip code, address, and city from the 'locations' table by performing a right join with the 'categories' table on matching location IDs, then groups the results accordingly, and sorts them in ascending order based on the minimum category name. The key tables involved are 'locations' and 'categories'."
"SELECT t1.description, t1.category_id, t1.category_name, COUNT(*) as count_preferred_contact_method FROM categories t1 RIGHT JOIN customer_contacts t2 ON t1.category_id = t2.customer_id GROUP BY t1.description, t1.category_id, t1.category_name ORDER BY count_preferred_contact_method DESC;","This query retrieves a list of categories with their descriptions and names, along with the count of preferred contact methods for each category by joining customer contact information from different tables. It orders the results in descending order based on the number of preferred contact methods per category."
"SELECT t1.payment_date, t1.order_id, MIN(t2.movement_type) as min_movement_type FROM payments t1 LEFT JOIN inventory_movements t2 ON t1.payment_id = t2.inventory_id GROUP BY t1.payment_date, t1.order_id ORDER BY min_movement_type DESC;","This SQL query retrieves the payment date and order ID for each payment, along with the earliest movement type (either 'IN' or 'OUT') associated with that payment from inventory movements, grouped by payment date and order ID. The results are ordered in descending order based on the earliest movement type."
"SELECT t1.customer_id, t1.order_date, MAX(t2.hire_date) as max_hire_date FROM orders t1 INNER JOIN employees t2 ON t1.order_id = t2.department_id GROUP BY t1.customer_id, t1.order_date ORDER BY t1.order_date ASC;","This SQL query retrieves the customer ID and order date from the orders table, along with the maximum hire date of employees associated with each order (based on department IDs), grouping results by customer ID and order date, and sorting them in ascending order by order date. The purpose is to analyze historical data for potential correlations between employee hiring dates and customer ordering patterns.

Key tables: orders, employees
Metrics: customer_id, order_date, max_hire_date"
"SELECT t1.movement_id, t1.movement_type, COUNT(*) as count_city FROM inventory_movements t1 RIGHT JOIN locations t2 ON t1.inventory_id = t2.location_id GROUP BY t1.movement_id, t1.movement_type ORDER BY t1.movement_id ASC;","This SQL query retrieves the movement ID and type from inventory movements (t1) table, counts the number of occurrences for each combination of movement ID and type by joining with locations table (t2), grouped by movement ID and type, to provide insights into different types of inventory movements across various cities."
"SELECT t1.city, t1.supplier_id, MIN(t2.status) as min_status FROM suppliers t1 RIGHT JOIN return_orders t2 ON t1.supplier_id = t2.return_id GROUP BY t1.city, t1.supplier_id ORDER BY t1.supplier_id DESC;","This query retrieves the city and supplier ID for each supplier, along with their minimum return order status (indicating the earliest occurrence of a return), grouped by city and supplier ID, and orders the results in descending order based on supplier ID. The key tables involved are 'suppliers' and 'return_orders'."
"SELECT t1.stock, t1.category_id, SUM(t2.description) as sum_description FROM products t1 INNER JOIN categories t2 ON t1.category_id = t2.category_id GROUP BY t1.stock, t1.category_id ORDER BY sum_description DESC;","This SQL query retrieves the stock and category ID from the 'products' table (t1) and calculates the total description count for each unique combination of stock and category ID by joining it with the 'categories' table (t2). The results are then grouped by stock and category ID, sorted in descending order based on the summed description counts."
"SELECT t1.supplier_name, t1.state, t1.supplier_id, COUNT(t2.movement_date) as count_movement_date FROM suppliers t1 INNER JOIN inventory_movements t2 ON t1.supplier_id = t2.inventory_id GROUP BY t1.supplier_name, t1.state, t1.supplier_id ORDER BY count_movement_date ASC;","This query retrieves the supplier name, state, and ID from the 'suppliers' table, along with a count of inventory movement dates for each supplier by joining it with the 'inventory_movements' table on their respective IDs. The results are grouped by supplier details and ordered in ascending order based on the number of movements."
"SELECT t1.stock, t1.category_id, COUNT(t2.phone) as count_phone FROM products t1 LEFT JOIN customer_contacts t2 ON t1.category_id = t2.contact_id GROUP BY t1.stock, t1.category_id ORDER BY count_phone DESC;","This SQL query retrieves the stock and category ID of products from the 'products' table, along with a count of associated phone numbers in the 'customer_contacts' table, grouping by product stock and category ID. It orders the results by the number of related phone contacts in descending order to identify popular products or categories based on customer contact information."
"SELECT t1.supplier_name, t1.city, MIN(t2.quantity) as min_quantity FROM suppliers t1 INNER JOIN inventory_movements t2 ON t1.supplier_id = t2.movement_id GROUP BY t1.supplier_name, t1.city ORDER BY min_quantity DESC;","This SQL query retrieves the name and city of each supplier along with their minimum inventory movement quantity, grouping results by supplier name and city, and orders them in descending order based on the minimum quantity. It joins data from the 'suppliers' table and 'inventory_movements' table using the supplier ID as a common key to identify relevant records."
"SELECT t1.quantity, t1.movement_id, t1.inventory_id, MAX(t2.tracking_number) as max_tracking_number FROM inventory_movements t1 LEFT JOIN shipments t2 ON t1.movement_id = t2.shipment_id GROUP BY t1.quantity, t1.movement_id, t1.inventory_id ORDER BY max_tracking_number ASC;","This SQL query retrieves the quantity and movement details of inventory items from the 'inventory_movements' table, while also obtaining the maximum tracking number associated with each item through a left join on the 'shipments' table. The results are grouped by quantity, movement ID, and inventory ID, and ordered ascendingly based on the maximum tracking number."
"SELECT t1.product_id, t1.inventory_id, COUNT(t2.category_name) as count_category_name FROM inventory t1 LEFT JOIN categories t2 ON t1.inventory_id = t2.category_id GROUP BY t1.product_id, t1.inventory_id ORDER BY count_category_name DESC;","This SQL query retrieves a list of products and their inventory IDs along with the number of categories each product belongs to, ordered by this category count in descending order, to help identify which products have the most diverse range of categories. It uses data from two tables: 'inventory' (t1) and 'categories' (t2)."
"SELECT t1.unit_price, t1.category_id, t1.product_id, SUM(t2.phone) as sum_phone FROM products t1 LEFT JOIN customer_contacts t2 ON t1.category_id = t2.customer_id GROUP BY t1.unit_price, t1.category_id, t1.product_id ORDER BY sum_phone DESC;","This SQL query retrieves the unit price, category ID, and product ID of products from the 'products' table, along with the total phone numbers associated with each product (from the 'customer_contacts' table), grouped by these attributes. It orders the results in descending order based on the sum of phone numbers for each product."
"SELECT t1.quantity, t1.unit_price, AVG(t2.first_name) as avg_first_name FROM order_details t1 RIGHT JOIN employees t2 ON t1.detail_id = t2.employee_id GROUP BY t1.quantity, t1.unit_price ORDER BY avg_first_name DESC;","This SQL query retrieves the quantity and unit price of each order detail from the 'order_details' table, along with the average first name of employees associated with those details (from the 'employees' table), grouped by both quantity and unit price. The results are ordered in descending order based on the calculated average first name.

Key tables: 
- order_details (t1)
- employees (t2)

Metrics:
- Quantity of each order detail
- Unit price of each order detail
- Average first name of associated employee"
"SELECT t1.phone, t1.customer_id, SUM(t2.movement_type) as sum_movement_type FROM customer_contacts t1 RIGHT JOIN inventory_movements t2 ON t1.contact_id = t2.movement_id GROUP BY t1.phone, t1.customer_id ORDER BY sum_movement_type ASC;","This query retrieves each customer's phone number and ID along with the total count of their inventory movements (positive or negative), grouping by phone and customer IDs in ascending order based on movement counts, using data from 'customer_contacts' and 'inventory_movements' tables."
"SELECT t1.amount, t1.order_id, t1.payment_method, MIN(t2.tracking_number) as min_tracking_number FROM payments t1 INNER JOIN shipments t2 ON t1.order_id = t2.order_id GROUP BY t1.amount, t1.order_id, t1.payment_method ORDER BY min_tracking_number ASC;","This SQL query retrieves the amount, order ID, and payment method for each unique combination of these attributes in the payments table (t1), along with the minimum tracking number associated with their corresponding shipment records in the shipments table (t2). The results are grouped by amount, order ID, and payment method, and ordered ascendingly based on the minimum tracking number."
"SELECT t1.city, t1.state, COUNT(t2.address) as count_address FROM suppliers t1 RIGHT JOIN locations t2 ON t1.supplier_id = t2.location_id GROUP BY t1.city, t1.state ORDER BY count_address DESC;","This SQL query retrieves the city and state from suppliers table (t1) along with a count of addresses associated with each location in the locations table (t2), grouped by city and state. It orders the results in descending order based on the number of addresses per location, to identify cities/states with the highest number of supplier addresses."
"SELECT t1.warehouse_id, t1.stock_level, SUM(t2.state) as sum_state FROM inventory t1 INNER JOIN customers t2 ON t1.inventory_id = t2.customer_id GROUP BY t1.warehouse_id, t1.stock_level ORDER BY t1.stock_level DESC;","This SQL query retrieves the warehouse ID and stock level from the inventory table (t1), and calculates the total state value for each warehouse by joining with the customers table (t2) on their respective IDs, then groups the results by warehouse ID and stock level. The output is ordered in descending order based on stock level to prioritize higher-stocked warehouses."
"SELECT t1.preferred_contact_method, t1.customer_id, t1.phone, AVG(t2.amount) as avg_amount FROM customer_contacts t1 INNER JOIN orders t2 ON t1.customer_id = t2.customer_id GROUP BY t1.preferred_contact_method, t1.customer_id, t1.phone ORDER BY avg_amount DESC;","This SQL query retrieves the preferred contact method, customer ID, and phone number from the 'customer_contacts' table, along with the average order amount per customer grouped by their preferred contact method, and sorts the results in descending order based on the average order amount. It aims to analyze customers' spending habits segmented by their chosen communication preferences."
"SELECT t1.status, t1.amount, t1.order_id, COUNT(*) as count_supplier_name FROM orders t1 INNER JOIN suppliers t2 ON t1.order_id = t2.supplier_id GROUP BY t1.status, t1.amount, t1.order_id ORDER BY count_supplier_name DESC;","This SQL query retrieves the status, amount, and order ID from orders table (t1) and counts the number of suppliers associated with each order by joining it with the suppliers table (t2). The results are grouped by status, amount, and order ID, and sorted in descending order based on the count of unique supplier names."
"SELECT t1.zip_code, t1.state, t1.address, MIN(t2.return_date) as min_return_date FROM locations t1 LEFT JOIN return_orders t2 ON t1.location_id = t2.order_id GROUP BY t1.zip_code, t1.state, t1.address ORDER BY t1.state DESC;","This SQL query retrieves the minimum return date for each unique location (defined by zip code, state, and address) from a locations table, by joining with a return_orders table on order ID, and groups the results by location attributes while sorting them in descending order based on state."
"SELECT t1.customer_id, t1.phone, MAX(t2.amount) as max_amount FROM customer_contacts t1 RIGHT JOIN payments t2 ON t1.contact_id = t2.payment_id GROUP BY t1.customer_id, t1.phone ORDER BY t1.customer_id DESC;","This SQL query retrieves the customer ID and phone number from the 'customer_contacts' table, along with their maximum payment amount from the 'payments' table, grouping results by customer ID and phone number, and ordering them in descending order based on customer ID. It aims to provide insights into each customer's highest payment history for analysis or reporting purposes."
"SELECT t1.order_date, t1.order_id, t1.status, MIN(t2.unit_price) as min_unit_price FROM orders t1 RIGHT JOIN products t2 ON t1.customer_id = t2.category_id GROUP BY t1.order_date, t1.order_id, t1.status ORDER BY t1.status ASC;","This SQL query retrieves the order date, order ID, and status from orders table (t1) along with the minimum unit price of products associated with each order by joining it with the products table (t2) based on customer IDs matching product categories. The results are grouped by order date, order ID, and status, sorted in ascending order by status."
"SELECT t1.payment_date, t1.order_id, SUM(t2.address) as sum_address FROM payments t1 RIGHT JOIN locations t2 ON t1.payment_id = t2.location_id GROUP BY t1.payment_date, t1.order_id ORDER BY sum_address ASC;","This query retrieves the payment date and order ID from a 'payments' table, along with the total address length (sum of characters in addresses) for each corresponding location from a 'locations' table, grouped by payment date and order ID. The results are sorted by the summed address lengths in ascending order.

Key tables: payments, locations; Metrics: payment_date, order_id, sum_address (sum of characters in addresses)."
"SELECT t1.customer_id, t1.preferred_contact_method, t1.email, AVG(t2.stock) as avg_stock FROM customer_contacts t1 INNER JOIN products t2 ON t1.contact_id = t2.product_id GROUP BY t1.customer_id, t1.preferred_contact_method, t1.email ORDER BY t1.preferred_contact_method ASC;","This SQL query retrieves the customer ID, preferred contact method, and email for each customer from the 'customer_contacts' table, along with their average stock level of products linked to them in the 'products' table. It groups results by customer details and sorts customers based on their preferred contact method."
"SELECT t1.carrier, t1.order_id, t1.shipment_id, MAX(t2.department_name) as max_department_name FROM shipments t1 LEFT JOIN departments t2 ON t1.order_id = t2.department_id GROUP BY t1.carrier, t1.order_id, t1.shipment_id ORDER BY max_department_name ASC;","This SQL query retrieves the carrier name, order ID, and shipment ID from a ""shipments"" table, along with the maximum department name associated with each order by performing a left join on a ""departments"" table. The results are grouped by carrier, order ID, and shipment ID, and ordered in ascending order based on the maximum department name found for each group."
"SELECT t1.phone, t1.customer_id, t1.contact_id, MAX(t2.description) as max_description FROM customer_contacts t1 RIGHT JOIN categories t2 ON t1.customer_id = t2.category_id GROUP BY t1.phone, t1.customer_id, t1.contact_id ORDER BY t1.contact_id ASC;","This SQL query retrieves each customer's phone number and contact ID along with the maximum description from their associated category for all records in the 'customer_contacts' table, grouping by phone, customer ID, and contact ID, and orders the results by contact ID. The key tables involved are 'customer_contacts' and 'categories'."
"SELECT t1.category_id, t1.category_name, SUM(t2.email) as sum_email FROM categories t1 INNER JOIN customers t2 ON t1.category_id = t2.customer_id GROUP BY t1.category_id, t1.category_name ORDER BY t1.category_id ASC;","This SQL query retrieves the total number of emails associated with each category by joining the 'categories' and 'customers' tables on their respective IDs, then groups the results by category ID and name, and orders them in ascending order based on category ID. The key metrics are category_id, category_name, and sum_email (total count of customer emails per category)."
"SELECT t1.phone, t1.email, t1.preferred_contact_method, COUNT(*) as count_department_name FROM customer_contacts t1 RIGHT JOIN departments t2 ON t1.customer_id = t2.department_id GROUP BY t1.phone, t1.email, t1.preferred_contact_method ORDER BY count_department_name ASC;","This SQL query retrieves the phone numbers, emails, and preferred contact methods of customers from the 'customer_contacts' table, along with a count of associated department names, by joining it with the 'departments' table on customer IDs. It groups the results by these details and orders them in ascending order based on the number of departments linked to each contact method."
"SELECT t1.carrier, t1.tracking_number, SUM(t2.email) as sum_email FROM shipments t1 LEFT JOIN customer_contacts t2 ON t1.order_id = t2.customer_id GROUP BY t1.carrier, t1.tracking_number ORDER BY t1.carrier DESC;","This SQL query retrieves the carrier and tracking number of shipments along with the total count of associated customer emails for each unique combination of carrier and tracking number, grouping by these two attributes in descending order based on the carrier name. It uses data from the 'shipments' table (t1) and a left join with the 'customer_contacts' table (t2) to combine shipment orders with customer emails."
"SELECT t1.order_id, t1.unit_price, t1.product_id, AVG(t2.product_name) as avg_product_name FROM order_details t1 LEFT JOIN products t2 ON t1.product_id = t2.product_id GROUP BY t1.order_id, t1.unit_price, t1.product_id ORDER BY avg_product_name ASC;","This SQL query retrieves the order ID, unit price, and product ID from the 'order_details' table (t1), along with the average product name for each order by joining it with the 'products' table (t2) on their common product IDs. The results are grouped by order ID, unit price, and product ID, and ordered in ascending order based on the calculated average product name."
"SELECT t1.location_id, t1.department_name, t1.department_id, COUNT(t2.product_name) as count_product_name FROM departments t1 INNER JOIN products t2 ON t1.location_id = t2.category_id GROUP BY t1.location_id, t1.department_name, t1.department_id ORDER BY t1.location_id DESC;","This SQL query retrieves the location ID, department name, and department ID from the 'departments' table, along with a count of distinct product names associated with each department in the 'products' table. It groups the results by location and department details, then orders them in descending order based on location ID."
"SELECT t1.product_name, t1.product_id, t1.unit_price, COUNT(t2.status) as count_status FROM products t1 LEFT JOIN return_orders t2 ON t1.category_id = t2.order_id GROUP BY t1.product_name, t1.product_id, t1.unit_price ORDER BY count_status ASC;","This SQL query retrieves a list of products with their names, IDs, and unit prices from the 'products' table, along with the total number of associated return orders for each product (counted by status) from the 'return_orders' table. The results are grouped by product name, ID, and price, ordered in ascending order based on the count of return orders."
"SELECT t1.product_id, t1.category_id, t1.product_name, COUNT(*) as count_city FROM products t1 INNER JOIN customers t2 ON t1.category_id = t2.customer_id GROUP BY t1.product_id, t1.category_id, t1.product_name ORDER BY count_city ASC;","This SQL query retrieves a list of products along with their category IDs and names, counting the number of cities where each product is sold, by joining the 'products' table with the 'customers' table based on matching category IDs. The results are grouped by product ID, category ID, and product name, then ordered in ascending order by the count of cities per product."
"SELECT t1.refund_amount, t1.status, MAX(t2.unit_price) as max_unit_price FROM return_orders t1 LEFT JOIN products t2 ON t1.return_id = t2.product_id GROUP BY t1.refund_amount, t1.status ORDER BY max_unit_price ASC;","This SQL query retrieves the refund amount and status from return orders (t1) and calculates the maximum unit price for each refund amount and status combination by joining with product information (t2). The results are grouped by refund amount and status, ordered in ascending order based on the maximum unit price."
"SELECT t1.last_updated, t1.stock_level, AVG(t2.movement_type) as avg_movement_type FROM inventory t1 LEFT JOIN inventory_movements t2 ON t1.inventory_id = t2.inventory_id GROUP BY t1.last_updated, t1.stock_level ORDER BY avg_movement_type DESC;","This SQL query retrieves the last updated timestamp and stock level from the inventory table (t1), along with the average movement type (either 'incoming' or 'outgoing') for each inventory item, calculated by joining it with the inventory movements table (t2). The results are grouped by last updated time and stock level, sorted in descending order based on the average movement type. This helps businesses monitor their inventory levels and track changes over time."
"SELECT t1.customer_id, t1.city, COUNT(*) as count_last_updated FROM customers t1 RIGHT JOIN inventory t2 ON t1.customer_id = t2.warehouse_id GROUP BY t1.customer_id, t1.city ORDER BY count_last_updated DESC;","This query retrieves a list of customer IDs and cities from the customers table (t1), along with the total number of times each city's data was updated in the inventory table (t2). It orders the results by the frequency of updates, showing which locations have had the most recent changes."
"SELECT t1.category_name, t1.category_id, COUNT(*) as count_movement_type FROM categories t1 LEFT JOIN inventory_movements t2 ON t1.category_id = t2.inventory_id GROUP BY t1.category_name, t1.category_id ORDER BY t1.category_id ASC;","This SQL query retrieves the category name and ID from the 'categories' table, along with a count of associated inventory movements for each category. It groups the results by category name and ID, then orders them in ascending order based on category ID. The purpose is to analyze inventory movement patterns across different categories."
"SELECT t1.state, t1.supplier_name, MIN(t2.refund_amount) as min_refund_amount FROM suppliers t1 INNER JOIN return_orders t2 ON t1.supplier_id = t2.return_id GROUP BY t1.state, t1.supplier_name ORDER BY min_refund_amount ASC;","This SQL query retrieves the state and supplier name from the 'suppliers' table, along with the minimum refund amount for each supplier-state combination by joining it with the 'return_orders' table on their respective IDs. The results are grouped by state and supplier name and ordered in ascending order based on the minimum refund amount."
"SELECT t1.address, t1.state, t1.zip_code, COUNT(*) as count_tracking_number FROM locations t1 RIGHT JOIN shipments t2 ON t1.location_id = t2.shipment_id GROUP BY t1.address, t1.state, t1.zip_code ORDER BY t1.state ASC;","This SQL query retrieves the address, state, and zip code of locations along with a count of associated shipments for each location. It groups results by address, state, and zip code in ascending order based on state to provide insights into tracking numbers' distribution across different locations.

Key tables: 
- locations (t1)
- shipments (t2)

Metrics: 
- count_tracking_number (COUNT(*))"
"SELECT t1.department_id, t1.department_name, MIN(t2.hire_date) as min_hire_date FROM departments t1 INNER JOIN employees t2 ON t1.department_id = t2.department_id GROUP BY t1.department_id, t1.department_name ORDER BY t1.department_id DESC;","This query retrieves the department ID and name along with the earliest hire date for each department by joining the departments and employees tables on their respective department IDs. It groups the results by department and orders them in descending order based on department ID. The key metric is the minimum hire date per department, which can help identify when a department was first staffed."
"SELECT t1.location_id, t1.department_id, t1.department_name, COUNT(t2.hire_date) as count_hire_date FROM departments t1 RIGHT JOIN employees t2 ON t1.department_id = t2.department_id GROUP BY t1.location_id, t1.department_id, t1.department_name ORDER BY count_hire_date ASC;","This SQL query retrieves the location ID, department ID, and department name from the departments table (t1), along with a count of employee hire dates for each department in that location, by joining it with the employees table (t2) on their common department_id. The results are grouped by location, department, and department name, ordered by the number of hires in ascending order."
"SELECT t1.shipment_id, t1.shipment_date, MAX(t2.unit_price) as max_unit_price FROM shipments t1 RIGHT JOIN order_details t2 ON t1.order_id = t2.order_id GROUP BY t1.shipment_id, t1.shipment_date ORDER BY max_unit_price DESC;","This SQL query retrieves the shipment ID and date for each shipment along with the maximum unit price of products in that shipment from a 'shipments' table joined to an 'order_details' table, grouping by shipment ID and date. The results are ordered by the highest unit price first."
"SELECT t1.department_id, t1.last_name, t1.hire_date, AVG(t2.stock) as avg_stock FROM employees t1 LEFT JOIN products t2 ON t1.employee_id = t2.product_id GROUP BY t1.department_id, t1.last_name, t1.hire_date ORDER BY t1.department_id DESC;","This SQL query retrieves the department ID, last name, and hire date of employees from the 'employees' table, along with the average stock value for each employee (grouped by their respective department) obtained from a left join on the 'products' table. The results are ordered by department ID in descending order."
"SELECT t1.hire_date, t1.first_name, t1.last_name, AVG(t2.email) as avg_email FROM employees t1 RIGHT JOIN customer_contacts t2 ON t1.department_id = t2.contact_id GROUP BY t1.hire_date, t1.first_name, t1.last_name ORDER BY avg_email DESC;","This SQL query retrieves the hire date and names of employees from the 'employees' table, while also calculating the average email address length for each employee by joining with the 'customer_contacts' table based on department ID. It then groups the results by hire date, first name, and last name, and orders them in descending order according to the calculated average email length."
"SELECT t1.zip_code, t1.state, AVG(t2.email) as avg_email FROM locations t1 RIGHT JOIN customers t2 ON t1.location_id = t2.customer_id GROUP BY t1.zip_code, t1.state ORDER BY avg_email ASC;","This SQL query calculates the average email length for each unique zip code and state combination in the locations table by joining it with the customers table on their respective IDs, then sorts the results in ascending order based on the calculated average email length. The key tables involved are 'locations' (t1) and 'customers' (t2), while the metric of interest is the average email length."
"SELECT t1.city, t1.state, COUNT(t2.return_date) as count_return_date FROM suppliers t1 RIGHT JOIN return_orders t2 ON t1.supplier_id = t2.order_id GROUP BY t1.city, t1.state ORDER BY t1.state DESC;","This SQL query retrieves the city and state of each supplier along with the total number of associated return dates from the 'return_orders' table, grouping results by city and state in descending order based on state. It helps to analyze the distribution of returned orders across different cities and states for suppliers."
"SELECT t1.inventory_id, t1.movement_id, SUM(t2.city) as sum_city FROM inventory_movements t1 LEFT JOIN customers t2 ON t1.inventory_id = t2.customer_id GROUP BY t1.inventory_id, t1.movement_id ORDER BY sum_city ASC;","This SQL query retrieves the total number of cities associated with each inventory movement by joining the 'inventory_movements' and 'customers' tables on their respective IDs. It groups the results by inventory ID and movement ID, then orders them in ascending order based on the summed city count."
"SELECT t1.price, t1.quantity, MAX(t2.unit_price) as max_unit_price FROM sales t1 INNER JOIN products t2 ON t1.product_id = t2.product_id GROUP BY t1.price, t1.quantity ORDER BY t1.quantity DESC;","This SQL query retrieves the price and quantity of each product sold from the 'sales' table (t1), along with the maximum unit price for that product from the 'products' table (t2). It groups the results by price and quantity, then orders them in descending order based on quantity."
"SELECT t1.unit_price, t1.stock, MAX(t2.shipment_date) as max_shipment_date FROM products t1 LEFT JOIN shipments t2 ON t1.product_id = t2.order_id GROUP BY t1.unit_price, t1.stock ORDER BY max_shipment_date DESC;","This SQL query retrieves the unit price and stock quantity of each product from the 'products' table, along with the latest shipment date for that product from the 'shipments' table, grouping results by unit price and stock level. The data is then ordered in descending order based on the most recent shipment date."
"SELECT t1.refund_amount, t1.status, t1.return_date, MIN(t2.carrier) as min_carrier FROM return_orders t1 LEFT JOIN shipments t2 ON t1.order_id = t2.order_id GROUP BY t1.refund_amount, t1.status, t1.return_date ORDER BY t1.return_date DESC;","This SQL query retrieves the refund amount, status, and return date of each order from the 'return_orders' table, along with the minimum carrier associated with that order (from the 'shipments' table), grouped by refund amount, status, and return date. The results are ordered in descending order based on the return date."
"SELECT t1.customer_id, t1.preferred_contact_method, t1.email, AVG(t2.unit_price) as avg_unit_price FROM customer_contacts t1 INNER JOIN order_details t2 ON t1.customer_id = t2.order_id GROUP BY t1.customer_id, t1.preferred_contact_method, t1.email ORDER BY avg_unit_price DESC;","This query retrieves the customer ID, preferred contact method, and email from the 'customer_contacts' table, along with the average unit price of their orders from the 'order_details' table, grouping by each unique combination of these attributes. It then sorts the results in descending order based on the calculated average unit price to identify customers who spend more on average per purchase."
"SELECT t1.movement_id, t1.movement_date, SUM(t2.carrier) as sum_carrier FROM inventory_movements t1 RIGHT JOIN shipments t2 ON t1.movement_id = t2.shipment_id GROUP BY t1.movement_id, t1.movement_date ORDER BY t1.movement_date DESC;","This SQL query retrieves the movement ID and date for each inventory movement, along with the total carrier count (sum of carriers) from shipments related to that movement. It groups the results by movement ID and date, displaying them in descending order based on the movement date. The key tables involved are 'inventory_movements' and 'shipments'."
"SELECT t1.department_id, t1.department_name, t1.location_id, MAX(t2.payment_date) as max_payment_date FROM departments t1 RIGHT JOIN payments t2 ON t1.location_id = t2.order_id GROUP BY t1.department_id, t1.department_name, t1.location_id ORDER BY max_payment_date ASC;","This SQL query retrieves the department ID, name, and location ID along with the most recent payment date for each department by joining the departments table (t1) with the payments table (t2), where their locations match. The results are grouped and ordered by the latest payment date in ascending order."
"SELECT t1.detail_id, t1.product_id, t1.quantity, SUM(t2.zip_code) as sum_zip_code FROM order_details t1 LEFT JOIN locations t2 ON t1.product_id = t2.location_id GROUP BY t1.detail_id, t1.product_id, t1.quantity ORDER BY t1.product_id DESC;","This SQL query retrieves the detail ID, product ID, and quantity of each order from the 'order_details' table, along with the sum of zip codes for corresponding locations from the 'locations' table (using a left join). It groups the results by detail ID, product ID, and quantity, then orders them in descending order based on product ID. The purpose is to analyze sales data by product while considering associated location information."
"SELECT t1.product_id, t1.stock_level, t1.warehouse_id, MIN(t2.city) as min_city FROM inventory t1 RIGHT JOIN suppliers t2 ON t1.product_id = t2.supplier_id GROUP BY t1.product_id, t1.stock_level, t1.warehouse_id ORDER BY min_city ASC;","This SQL query retrieves the product ID, stock level, and warehouse ID from the inventory table, along with the minimum city name associated with each product through a right join on suppliers based on matching product IDs. The results are grouped by product ID, stock level, and warehouse ID, ordered ascendingly by the minimum city name."
"SELECT t1.sale_id, t1.quantity, t1.price, MAX(t2.movement_type) as max_movement_type FROM sales t1 INNER JOIN inventory_movements t2 ON t1.product_id = t2.inventory_id GROUP BY t1.sale_id, t1.quantity, t1.price ORDER BY t1.quantity DESC;","This SQL query retrieves the sale ID, quantity sold, and price for each product from the sales table (t1), along with the maximum movement type in the inventory movements table (t2) where the product IDs match. The results are grouped by sale ID, sorted by quantity in descending order."
"SELECT t1.payment_id, t1.amount, t1.order_id, SUM(t2.movement_date) as sum_movement_date FROM payments t1 LEFT JOIN inventory_movements t2 ON t1.order_id = t2.movement_id GROUP BY t1.payment_id, t1.amount, t1.order_id ORDER BY sum_movement_date DESC;","This SQL query retrieves payment details (payment ID, amount, and order ID) from the payments table, along with the total count of inventory movement dates associated with each payment's corresponding order by joining it with the inventory movements table. The results are grouped by payment ID, amount, and order ID, and ordered in descending order based on the sum of movement dates for each payment."
"SELECT t1.sale_date, t1.price, COUNT(t2.payment_date) as count_payment_date FROM sales t1 INNER JOIN payments t2 ON t1.product_id = t2.order_id GROUP BY t1.sale_date, t1.price ORDER BY count_payment_date DESC;","This SQL query retrieves the sale date and price from the sales table (t1), along with a count of payment dates associated with each sale in the payments table (t2) based on matching product IDs. It groups the results by sale date and price, ordering them in descending order based on the number of related payment dates. The purpose is to analyze sales data for insights into transaction frequency and pricing trends."
"SELECT t1.tracking_number, t1.order_id, MIN(t2.movement_date) as min_movement_date FROM shipments t1 LEFT JOIN inventory_movements t2 ON t1.order_id = t2.movement_id GROUP BY t1.tracking_number, t1.order_id ORDER BY min_movement_date DESC;","This SQL query retrieves the tracking number and order ID for each shipment along with the earliest movement date from inventory movements (t2) associated with that specific order (t1), grouping results by tracking number and order ID, and ordering them in descending order based on the minimum movement date. The key tables involved are 'shipments' (t1) and 'inventory_movements' (t2)."
"SELECT t1.amount, t1.payment_method, MIN(t2.carrier) as min_carrier FROM payments t1 RIGHT JOIN shipments t2 ON t1.order_id = t2.order_id GROUP BY t1.amount, t1.payment_method ORDER BY min_carrier ASC;","This SQL query retrieves the amount and payment method of each order from the payments table, along with the carrier associated with that order in the shipments table (using a right join to include all orders), then groups the results by amount and payment method. It also selects the minimum carrier for each group and sorts the output by this minimum carrier in ascending order. The purpose is likely to analyze payment methods and carriers used, identifying any patterns or trends related to these metrics."
"SELECT t1.amount, t1.payment_id, t1.order_id, MAX(t2.description) as max_description FROM payments t1 RIGHT JOIN categories t2 ON t1.payment_id = t2.category_id GROUP BY t1.amount, t1.payment_id, t1.order_id ORDER BY t1.order_id DESC;","This SQL query retrieves the amount and payment details for each order, along with the maximum category description associated with each payment, by joining payments (t1) and categories (t2) tables on their respective IDs, grouping results by amount, payment ID, and order ID, and ordering them in descending order based on order ID. The purpose is to analyze payment details within orders while considering related category descriptions."
"SELECT t1.last_name, t1.department_id, t1.hire_date, COUNT(*) as count_stock_level FROM employees t1 RIGHT JOIN inventory t2 ON t1.department_id = t2.inventory_id GROUP BY t1.last_name, t1.department_id, t1.hire_date ORDER BY t1.hire_date DESC;","This SQL query retrieves the last name, department ID, and hire date of employees from the 'employees' table, along with a count of their associated inventory items in the 'inventory' table (if any), grouped by employee details and sorted by most recent hire date. It helps to analyze stock levels per employee across departments over time."
"SELECT t1.supplier_name, t1.state, SUM(t2.department_name) as sum_department_name FROM suppliers t1 INNER JOIN departments t2 ON t1.supplier_id = t2.location_id GROUP BY t1.supplier_name, t1.state ORDER BY sum_department_name ASC;","This SQL query retrieves the total number of distinct department names associated with each supplier and state from a join between the 'suppliers' and 'departments' tables, grouping by supplier name and state, and orders the results in ascending order based on the sum of department names."
"SELECT t1.status, t1.amount, COUNT(t2.return_date) as count_return_date FROM orders t1 INNER JOIN return_orders t2 ON t1.order_id = t2.order_id GROUP BY t1.status, t1.amount ORDER BY count_return_date DESC;","This query retrieves the status and amount of each order from the 'orders' table, along with a count of associated return dates from the 'return_orders' table, grouped by order status and amount. It orders the results in descending order based on the number of return dates for each order."
"SELECT t1.state, t1.zip_code, AVG(t2.carrier) as avg_carrier FROM locations t1 RIGHT JOIN shipments t2 ON t1.location_id = t2.order_id GROUP BY t1.state, t1.zip_code ORDER BY t1.zip_code DESC;","This SQL query calculates the average carrier for each state and zip code by joining locations with shipments on their respective IDs, then groups the results by state and zip code in descending order of zip codes. The result helps analyze shipping patterns across different regions.

Key tables: locations (t1), shipments (t2)
Metrics: average carrier per state/zip code, grouped by state and zip code, sorted by zip code in descending order."
"SELECT t1.category_name, t1.description, MAX(t2.unit_price) as max_unit_price FROM categories t1 INNER JOIN products t2 ON t1.category_id = t2.category_id GROUP BY t1.category_name, t1.description ORDER BY t1.description DESC;","This SQL query retrieves the maximum unit price for each product category along with its name and description from a joined 'categories' and 'products' table, then sorts the results by category description in descending order. The key metrics are category_name, description, and max_unit_price."
"SELECT t1.category_id, t1.stock, AVG(t2.return_date) as avg_return_date FROM products t1 LEFT JOIN return_orders t2 ON t1.product_id = t2.order_id GROUP BY t1.category_id, t1.stock ORDER BY avg_return_date DESC;","This SQL query retrieves the average return date and stock levels for each product category by joining products table with a returns orders table on their respective IDs. The results are grouped by category ID and stock level, then ordered in descending order based on the calculated average return date."
"SELECT t1.order_id, t1.payment_date, t1.amount, MAX(t2.status) as max_status FROM payments t1 RIGHT JOIN return_orders t2 ON t1.order_id = t2.order_id GROUP BY t1.order_id, t1.payment_date, t1.amount ORDER BY max_status DESC;","This SQL query retrieves the order ID, payment date, and amount from a payments table (t1), while also obtaining the latest status of each order by performing a right join with a return orders table (t2) on their common order IDs. The results are grouped by order ID, payment date, and amount, and sorted in descending order based on the maximum status value obtained from t2. This helps identify any outstanding or resolved issues related to specific payments."
"SELECT t1.status, t1.customer_id, MIN(t2.stock_level) as min_stock_level FROM orders t1 LEFT JOIN inventory t2 ON t1.customer_id = t2.warehouse_id GROUP BY t1.status, t1.customer_id ORDER BY min_stock_level DESC;","This SQL query retrieves the minimum stock level for each customer's order status and customer ID by joining orders (t1) with inventory (t2) on matching warehouse IDs, grouping the results by status and customer ID, and ordering them in descending order based on the lowest stock levels. The key metrics are the order status, customer ID, and minimum stock level for each group."
"SELECT t1.quantity, t1.product_id, AVG(t2.refund_amount) as avg_refund_amount FROM order_details t1 RIGHT JOIN return_orders t2 ON t1.order_id = t2.order_id GROUP BY t1.quantity, t1.product_id ORDER BY avg_refund_amount ASC;","This SQL query retrieves the quantity and product ID from order details table (t1) and calculates the average refund amount for each unique combination of quantity and product ID by joining it with return orders table (t2). The results are grouped by quantity and product ID, sorted in ascending order based on the calculated average refund amount. This helps businesses understand their products' refund patterns and identify potential issues or opportunities for improvement."
"SELECT t1.sale_id, t1.product_id, t1.quantity, AVG(t2.preferred_contact_method) as avg_preferred_contact_method FROM sales t1 INNER JOIN customer_contacts t2 ON t1.product_id = t2.contact_id GROUP BY t1.sale_id, t1.product_id, t1.quantity ORDER BY avg_preferred_contact_method DESC;","This SQL query retrieves the sale ID, product ID, and quantity of each sale from the 'sales' table, along with the average preferred contact method for those products by joining it with the 'customer_contacts' table. It groups the results by sale ID, product ID, and quantity, then orders them in descending order based on the average preferred contact method."
